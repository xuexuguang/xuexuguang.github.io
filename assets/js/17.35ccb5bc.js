(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{517:function(s,a,t){"use strict";t.r(a);var e=t(15),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"缓存方案对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存方案对比"}},[s._v("#")]),s._v(" 缓存方案对比")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th"),s._v(" "),t("th",[s._v("EhCache")]),s._v(" "),t("th",[s._v("memcached")]),s._v(" "),t("th",[s._v("Redis")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("优点")]),s._v(" "),t("td",[s._v("基于java开发，与java项目的整合度更好；基于jvm缓存；轻巧方便")]),s._v(" "),t("td",[s._v("kv存储；多核多线程；内存使用率高；")]),s._v(" "),t("td",[s._v("丰富的数据结构；持久化；主从同步，故障转移；内存数据库；")])]),s._v(" "),t("tr",[t("td",[s._v("缺点")]),s._v(" "),t("td",[s._v("不支持集群，分布式支持不友好，")]),s._v(" "),t("td",[s._v("无法容灾，数据无法持久化；")]),s._v(" "),t("td",[s._v("单线程、单核；")])]),s._v(" "),t("tr",[t("td",[s._v("适合场景")]),s._v(" "),t("td",[s._v("适合单体应用，并发量较小的场景")]),s._v(" "),t("td",[s._v("适合缓存热数据")]),s._v(" "),t("td",[s._v("适合缓存、有存储需求的")])])])]),s._v(" "),t("h2",{attrs:{id:"redis架构与原理解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis架构与原理解析"}},[s._v("#")]),s._v(" Redis架构与原理解析")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201203184416514.png",alt:"image-20201203184416514"}}),s._v(" "),t("p",[s._v("多路复用：redis的多路复用器是是同步非阻塞模型，可以高效的处理多个客户端的连接，通过将请求投递到队列")]),s._v(" "),t("p",[s._v("文件事件分配器：通过从队列读取消息，分发到连接应答器")]),s._v(" "),t("p",[s._v("连接应答器：读取事件分配器分发的任务，递交命令请求处理器处理")]),s._v(" "),t("h2",{attrs:{id:"持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[s._v("#")]),s._v(" 持久化")]),s._v(" "),t("p",[s._v("redis通过持久化来保证数据的可靠性，主要包括rdb和aof两种方式；")]),s._v(" "),t("h3",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[s._v("#")]),s._v(" RDB")]),s._v(" "),t("p",[s._v("每隔一段时间，通过将内存中的数据作为快照存储到磁盘的临时文件，发生宕机的时候，读取磁盘快照的方式来恢复数据。")]),s._v(" "),t("h4",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[s._v("#")]),s._v(" 优缺点")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("优点")]),s._v(" "),t("th",[s._v("缺点")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("数据的全量备份")]),s._v(" "),t("td",[s._v("发生故障时，会丢失最后一次的备份数据")])]),s._v(" "),t("tr",[t("td",[s._v("数据作为文件，可以远程传输")]),s._v(" "),t("td",[s._v("子进程所占用的内存比会和父进程一模一样，如会造成CPU负担")])]),s._v(" "),t("tr",[t("td",[s._v("子进程备份的时候，主进程不会有任何io操作（不会有写入修改或删除），保证备份数据的的完整性")]),s._v(" "),t("td",[s._v("由于定时全量备份是重量级操作，所以对于实时备份，就无法处理了")])])])]),s._v(" "),t("h4",{attrs:{id:"配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[s._v("#")]),s._v(" 配置")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("save "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("9000")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 如果1个缓存更新，则15分钟后备份")]),s._v("\nsave "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("300")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 如果10个缓存更新，则5分钟后备份")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("h3",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[s._v("#")]),s._v(" AOF")]),s._v(" "),t("p",[s._v("RDB会丢失最后一次备份的rdb文件，但是其实也无所谓，其实也可以忽略不计，毕竟是缓存，丢了就丢了，但是如果追求数据的完整性，那就考虑使用AOF，aof有如下的特点：")]),s._v(" "),t("ol",[t("li",[s._v("以日志的形式来记录用户请求的写操作。读操作不会记录，因为写操作才会存存储；")]),s._v(" "),t("li",[s._v("文件以追加的形式而不是修改的形式；")]),s._v(" "),t("li",[s._v("redis的aof恢复其实就是把追加的文件从开始到结尾读取执行写操作；")])]),s._v(" "),t("h4",{attrs:{id:"优缺点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-2"}},[s._v("#")]),s._v(" 优缺点")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("优点")]),s._v(" "),t("th",[s._v("缺点")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("AOF更加耐用，可以以秒级别为单位备份，如果发生问题，也只会丢失最后一秒的数据，大大增加了可靠性和数据完整性。所以AOF可一次使用fsync操作")]),s._v(" "),t("td",[s._v("相同的数据，同一份数据，AOF比RDB大")])]),s._v(" "),t("tr",[t("td",[s._v("以log日志形式追加，如果磁盘满了，会执行 redis-check-aof 工具")]),s._v(" "),t("td",[s._v("针对不同的同步机制，AOF会比RDB慢，因为AOF每秒都会备份做写操作，这样相对与RDB来说就略低。每秒备份fsync没毛病，但是每次写入就做一次备份fsync的话，那么redis的性能就会下降")])]),s._v(" "),t("tr",[t("td",[s._v("当数据太大的时候，redis可以在后台自动重写aof。当redis继续把日志追加到老的文件中去时，重写也是非常安全的，不会影响客户端作")]),s._v(" "),t("td",[s._v("AOF发生过bug，就是数据恢复的时候数据不完整，这样显得AOF会比较脆弱，容易出现bug，因为AOF没有RDB那么简单，但是呢为的产生，AOF就不会根据旧的指令去重构，而是根据当时缓存中存在的数据指令去做重构，这样就")])]),s._v(" "),t("tr",[t("td",[s._v("AOF 日志包含的所有写操作，会更加便于redis的解析恢复")]),s._v(" "),t("td")])])]),s._v(" "),t("h4",{attrs:{id:"配置-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置-2"}},[s._v("#")]),s._v(" 配置")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF默认关闭，yes可以开启")]),s._v("\nappendonly no\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# AOF的文件名")]),s._v("\nappend filename "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"appendonly.aof"')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# no：不同步")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# everysec：每秒备份，推荐使用")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# always：每次操作都会备份，安全并且数据完整，但是慢性能差")]),s._v("\nappendf "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("sync")]),s._v(" everysec \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 重写的时候是否要同步，no可以保证数据安全")]),s._v("\nno-appendfsync-on-rewrite no\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 重写机制：避免文件越来越大，自动优化压缩指令，会fork一个新的进程去完成重写动作，新进程里的内存数据会被重写")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#当前AOF文件的大小是上次AOF大小的100%，并且文件体积达到64m，满足两者则触发重写")]),s._v("\nauto-aof-rewrite-percentage "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v("\nauto-aof-rewrite-min-size 64mb\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br")])]),t("h3",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),t("p",[s._v("到底采用RDB还是AOF呢？")]),s._v(" "),t("ol",[t("li",[s._v("如果你能接受一段时间的缓存丢失，那么可以使用RDB")]),s._v(" "),t("li",[s._v("如果你对实时性的数据比较care，那么就用AOF")])]),s._v(" "),t("h2",{attrs:{id:"主从复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[s._v("#")]),s._v(" 主从复制")]),s._v(" "),t("h3",{attrs:{id:"基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本原理"}},[s._v("#")]),s._v(" 基本原理")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201214113835998.png",alt:"image-20201214113835998"}}),s._v(" "),t("p",[s._v("主从复制架构是一主一从或者一主多从，支持主节点复制数据到从，不支持从复制到主。通过主从的形式来提高数据的处理能力。")]),s._v(" "),t("h3",{attrs:{id:"同步流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步流程"}},[s._v("#")]),s._v(" "),t("strong",[s._v("同步流程")])]),s._v(" "),t("ol",[t("li",[s._v("master节点开启持久化机制")]),s._v(" "),t("li",[s._v("slave节点ping master节点确认互通")]),s._v(" "),t("li",[s._v("master节点内存数据落到磁盘的rdb上")]),s._v(" "),t("li",[s._v("通过内网传输到slave节点上")]),s._v(" "),t("li",[s._v("slave节点下载rdb到磁盘后，加载到内存")]),s._v(" "),t("li",[s._v("master节点后续新的写操作，同步传输到slave节点，slave节点更新内存数据")])]),s._v(" "),t("p",[s._v("主从同步的时候，有以下几点注意：")]),s._v(" "),t("ul",[t("li",[s._v("数据同步过程中，读写不会进行阻塞，原因是由于对外提供的是老数据，数据同步完成后，会使用新数据提供服务")]),s._v(" "),t("li",[s._v("slave节点宕机后，会进行增量数据恢复")]),s._v(" "),t("li",[s._v("master节点必须开启持久化，否则重启后会导致数据清空")])]),s._v(" "),t("h3",{attrs:{id:"主从搭建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从搭建"}},[s._v("#")]),s._v(" 主从搭建")]),s._v(" "),t("p",[s._v("配置从节点的redis的配置")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 配置master节点的ip和端口")]),s._v("\nreplicaof "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("master"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("masterport"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# master的密码")]),s._v("\nmasterauth "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("master-password"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 是否只读")]),s._v("\nreplica-read-only "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("重启redis")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("service")]),s._v(" redis restart\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("h2",{attrs:{id:"无磁盘化复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无磁盘化复制"}},[s._v("#")]),s._v(" 无磁盘化复制")]),s._v(" "),t("p",[s._v("主要是通过socket的方式传输rdb数据，数据不会落到磁盘上。适用于网络性能好，磁盘吞吐量较低的情况下")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("repl-diskless-sync "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("h2",{attrs:{id:"缓存清理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存清理"}},[s._v("#")]),s._v(" 缓存清理")]),s._v(" "),t("p",[s._v("设置了expire的key缓存过期了，但是服务器的内存还是会被占用，这是因为redis所基于的两种删除策略：")]),s._v(" "),t("h3",{attrs:{id:"主动删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主动删除"}},[s._v("#")]),s._v(" 主动删除")]),s._v(" "),t("p",[s._v("定时随机的检查过期的key，如果过期则清理删除。（每秒检查次数在redis.conf中的"),t("a",{attrs:{href:"https://help.aliyun.com/document_detail/142171.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("hz"),t("OutboundLink")],1),s._v("配置）")]),s._v(" "),t("h3",{attrs:{id:"惰性删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除"}},[s._v("#")]),s._v(" 惰性删除")]),s._v(" "),t("p",[s._v("当客户端请求一个已经过期的key的时候，那么redis会检查这个key是否过期，如果过期了，则删除，然后返回一个nil")]),s._v(" "),t("h3",{attrs:{id:"淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#淘汰策略"}},[s._v("#")]),s._v(" 淘汰策略")]),s._v(" "),t("p",[s._v("maxmemory：当内存已使用率到达，则开始清理缓存")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("策略")]),s._v(" "),t("th",[s._v("说明")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("noeviction")]),s._v(" "),t("td",[s._v("旧缓存永不过期，新缓存设置不了，返回错误")])]),s._v(" "),t("tr",[t("td",[s._v("allkeys-lru")]),s._v(" "),t("td",[s._v("清除最少用的旧缓存，然后保存新的缓存（推荐使用）")])]),s._v(" "),t("tr",[t("td",[s._v("allkeys-random")]),s._v(" "),t("td",[s._v("所有的缓存中随机删除（不推荐）")])]),s._v(" "),t("tr",[t("td",[s._v("volatile-lru")]),s._v(" "),t("td",[s._v("在那些设置了expire过期时间的缓存中，清除最少用的旧缓存，然后保存新的缓存")])]),s._v(" "),t("tr",[t("td",[s._v("volatile-random")]),s._v(" "),t("td",[s._v("在那些设置了expire过期时间的缓存中，随机删除缓存")])]),s._v(" "),t("tr",[t("td",[s._v("volatile-ttl")]),s._v(" "),t("td",[s._v("在那些设置了expire过期时间的缓存中，删除即将过期的")])])])]),s._v(" "),t("h2",{attrs:{id:"哨兵模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),t("p",[s._v("哨兵是由多个节点组成的，用于监控redis各个节点的状态，宕机之后选取新的master节点来保证服务的可用性。")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201215102752537.png",alt:"image-20201215102752537"}}),s._v(" "),t("p",[t("strong",[s._v("配置哨兵")])]),s._v(" "),t("p",[s._v("在多台机器配置哨兵，监控redis的master、slave")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("## 通用配置")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 关闭受保护模式，方便哨兵各个节点相互访问")]),s._v("\nprotected-mode no \nport "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("26379")]),s._v(" \ndaemonize "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\npidfile /var/run/redis-sentinel pid\nLogfile /usr/Local/redis/sentinel/Redis-sentinel Log "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /usr/Local/redis/sentinel\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("## 核心配置")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 该行的意思是：监控的master的名字叫做mymaster （可以自定义），地址为192.168.1.191:6379，行尾最后的一个2代表在sentinel集群中，多少个sentinel认为master死了，才能真正认为该master不可用了。")]),s._v("\nsentinel monitor mymaster "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".1.191 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 密码为redis的密码")]),s._v("\nsentinel auth-pass mymaster "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("password"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# master在30s内无法ping通，会被sentinel认定为失效")]),s._v("\nsentinel down-after-mitliseconds mymaster "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("30000")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# salve节点被选取为新的master节点后，支持同时给几个salve进行数据同步")]),s._v("\nsentinel parallel-syncs mymaster "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 主备切换的超时时间，哨兵要去做故障转移，这个时候哨兵也是一个进程，如果他没有去执行，超过这个时间后，会由其他的哨兵负责处理")]),s._v("\nsentinel failover-timeout mymaster "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("180000")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br")])]),t("p",[s._v("启动哨兵")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("/usr/local/bin/redis-sentinel sentinel.conf \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("哨兵信息检查")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看mymaster下的master节点信息")]),s._v("\nsentinel master mymaster\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看mymaster下的slaves节点信息")]),s._v("\nsentinel slaves mymaster\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看mymaster下的哨兵节点信息")]),s._v("\nsentinel sentinels mymaster\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[t("strong",[s._v("注")]),s._v("：master宕机之后，重启之后，会变更为slave，这点跟keepalive的nginx的master是相反的。")]),s._v(" "),t("p",[s._v("master宕机后如果没有设置密码，会出现数据不一致的问题，因为没有进行auth所以无法进行数据同步。一般master数据无法同步给slave的方案检查为如下：")]),s._v(" "),t("ol",[t("li",[s._v("网络通信问题，要保证互相ping通，内网互通。")]),s._v(" "),t("li",[s._v("关闭防火墙，对应的端口开发（虚拟机中建议永久关闭防火墙，云服务器的话需要保证内网互通）。")]),s._v(" "),t("li",[s._v("统一所有的密码，不要漏了某个节点没有设置")])]),s._v(" "),t("h2",{attrs:{id:"集群原理及解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群原理及解决方案"}},[s._v("#")]),s._v(" 集群原理及解决方案")]),s._v(" "),t("p",[s._v("主从复制以及哨兵，他们可以提高读的并发，但是单个master容量有限，数据达到一定程度会有瓶颈。这个时候可以通过水平扩展为多master集群。")]),s._v(" "),t("p",[s._v("redis-cluster可以支撑多个master-slave，支持海量数据，实现高可用与高并发。")]),s._v(" "),t("p",[s._v("哨兵模式其实也是一种集群，他能够提高读请求的并发，但是容错方面可能会有一些问题，比如master同步数据给slave的时候，slave上的数据就没有master新，数据同步需要时间的，1-2秒的数据会丢失。master恢复并转换成slave后，新数据则丢失；")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201215142517282.png",alt:"image-20201215142517282"}}),s._v(" "),t("h3",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[s._v("#")]),s._v(" 特点")]),s._v(" "),t("ol",[t("li",[s._v("每个节点知道彼此之间的关系，也会知道自己的角色，当然他们也会知道自己存在于一个集群环境中，他们彼此之间可以交互和通信，那么这些关系都会保存到某个配置文件中。")]),s._v(" "),t("li",[s._v("客户端要和集群建立连接的话，只需要和其中一个建立关系就行。")]),s._v(" "),t("li",[s._v("某个节点挂了，也是通过超过半数的节点来进行的检测，客观下线后主从切换。")]),s._v(" "),t("li",[s._v("Redis中存在很多的插槽，又可以称之为槽节点，用于存储数据")])]),s._v(" "),t("h3",{attrs:{id:"集群容错"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群容错"}},[s._v("#")]),s._v(" 集群容错")]),s._v(" "),t("p",[s._v("构建Redis集群，至少需要3个节点作为master，以此组成一个高可用的集群，此外每个master都需要配备一个slave，所以整个集群需要6个节点，这也是最经典的集群，也可以称之为三主三从，容错性更佳。")]),s._v(" "),t("h3",{attrs:{id:"配置-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置-3"}},[s._v("#")]),s._v(" 配置")]),s._v(" "),t("p",[s._v("redis.conf的配置")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 开启集群模式")]),s._v("\ncluster-enabled "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 每一个节点需要有一个配置文件，需要6份。每个节点处于集群的角色都需要告知其他所有节点")]),s._v("\ncluster-config-file nodes-201.conf\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 超时时间，超时则认为master宕机，随后主备切换")]),s._v("\ncluster-node-timeout "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5000")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 开启AOF")]),s._v("\nappendonly "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("启动redis的实例")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 启动过程有问题，删除rdb文件")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("service")]),s._v(" redis start\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("创建集群")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 新版的redis集群创建使用redis-cli，主节点和从节点比例为1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# slots：槽，用于装数据，主节点有，从节点没有")]),s._v("\nredis-cli --cluster -a "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("password"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" create ip1:port1 ip2:port2 ip3:port3 ip4:port4 ip5:port5 ip6:port6 --cluster-replicas "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("检查集群信息")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("redis-cli --cluster check "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".25.64:6380\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("h2",{attrs:{id:"slot槽节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slot槽节点"}},[s._v("#")]),s._v(" Slot槽节点")]),s._v(" "),t("p",[s._v("slot主要是用于存储redis的数据")]),s._v(" "),t("h3",{attrs:{id:"分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分配"}},[s._v("#")]),s._v(" 分配")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201216102449247.png",alt:"image-20201216102449247"}}),s._v(" "),t("p",[s._v("槽总数为16348，会被平均的分配到master的各个节点上")]),s._v(" "),t("h3",{attrs:{id:"存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[s._v("#")]),s._v(" 存储")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://gitee.com/xuexuguang/images/raw/master/img/image-20201216102613004.png",alt:"image-20201216102613004"}}),s._v(" "),t("p",[s._v("集群模式下redis的key通过对key进行hash求模，最终计算得到数据落到哪个master的节点上。取数据的时候，会重定向到对应的节点上。")]),s._v(" "),t("h2",{attrs:{id:"参考链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[s._v("#")]),s._v(" 参考链接")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000003063859",target:"_blank",rel:"noopener noreferrer"}},[s._v("Linux IO模式及 select、poll、epoll详解"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844903886189395982",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis的持久化详解"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844904191236767751#heading-4",target:"_blank",rel:"noopener noreferrer"}},[s._v("主从模式"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/fcd40e2f9d19",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis哨兵模式的安装"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/LXDOS/article/details/106419743",target:"_blank",rel:"noopener noreferrer"}},[s._v("laravel集成哨兵模式"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/fe7b7800473e",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis Cluster及hash slot 算法"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000022029639",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis 缓存雪崩、击穿、穿透"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844904182609084424",target:"_blank",rel:"noopener noreferrer"}},[s._v("看完这篇Redis缓存三大问题，保你面试能造火箭，工作能拧螺丝"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);
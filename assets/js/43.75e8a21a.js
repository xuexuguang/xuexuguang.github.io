(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{543:function(a,t,v){"use strict";v.r(t);var _=v(15),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"分区表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区表"}},[a._v("#")]),a._v(" 分区表")]),a._v(" "),v("h3",{attrs:{id:"工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[a._v("#")]),a._v(" 工作原理")]),a._v(" "),v("p",[a._v("对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。对代码而言不需要任何的改变。")]),a._v(" "),v("p",[a._v("创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤哪些没有我们需要数据的分区。这样查询只查询所需数据所在的空间。")]),a._v(" "),v("h3",{attrs:{id:"适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[a._v("#")]),a._v(" 适用场景")]),a._v(" "),v("ul",[v("li",[a._v("表非常大，无法全部存在内存，或者只在表的最后有点热点数据，其他都是历史数据。")]),a._v(" "),v("li",[a._v("分区表的数据更易维护，可以对独立的分区进行独立的操作。")]),a._v(" "),v("li",[a._v("分区表的数据可以分布在不同的机器上，从而高效的利用资源")]),a._v(" "),v("li",[a._v("可以使用分区表避免某些瓶颈")])]),a._v(" "),v("h3",{attrs:{id:"限制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[a._v("#")]),a._v(" 限制")]),a._v(" "),v("ul",[v("li",[a._v("一个表最多有1024个分区")]),a._v(" "),v("li",[a._v("2.5.1版本中，分区表表达式必须是整数，5.5可以使用列分区。")]),a._v(" "),v("li",[a._v("分区字段中如果有主键和唯一索引列，那么主键和唯一索引必须包含进来")]),a._v(" "),v("li",[a._v("分区表中无法使用外键约束")]),a._v(" "),v("li",[a._v("需要对现有表的结构修改")]),a._v(" "),v("li",[a._v("所有分区必须使用相同的存储引擎")]),a._v(" "),v("li",[a._v("分区函数中可以使用的函数和表达式会有一些限制")]),a._v(" "),v("li",[a._v("某些存储引擎不支持分区")]),a._v(" "),v("li",[a._v("对于MyISAM的分区表不能使用load into cache")]),a._v(" "),v("li",[a._v("对于MyISAM表，使用分区表时需要打开更多的文件描述符")])]),a._v(" "),v("h2",{attrs:{id:"分库分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[a._v("#")]),a._v(" 分库分表")]),a._v(" "),v("h3",{attrs:{id:"工作原理-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作原理-2"}},[a._v("#")]),a._v(" 工作原理")]),a._v(" "),v("p",[a._v("通过hash算法或者一些工具，将数据表垂直或者水平进行物理拆分")]),a._v(" "),v("h3",{attrs:{id:"适用场景-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-2"}},[a._v("#")]),a._v(" 适用场景")]),a._v(" "),v("ul",[v("li",[a._v("单表级别达到了百万或者千万级别")]),a._v(" "),v("li",[a._v("解决表锁的问题")])]),a._v(" "),v("h3",{attrs:{id:"分表方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分表方式"}},[a._v("#")]),a._v(" 分表方式")]),a._v(" "),v("h4",{attrs:{id:"水平分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#水平分表"}},[a._v("#")]),a._v(" 水平分表")]),a._v(" "),v("p",[a._v("水平分割：表很大，分割后可以降低在查询时读取的数据和索引的页数，同时也降低了索引的层数，提高了查询速度。")]),a._v(" "),v("h5",{attrs:{id:"适用场景-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-3"}},[a._v("#")]),a._v(" 适用场景")]),a._v(" "),v("ul",[v("li",[a._v("表中的数据具有独立性，例如表中分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些数据不常用。")]),a._v(" "),v("li",[a._v("需要把数据放在不同介质上")])]),a._v(" "),v("h5",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("给应用增加复杂度，通常查询时需要多个表名，查询的数据需要进行UNION操作")]),a._v(" "),v("li",[a._v("在许多数据库应用中，这种复杂性会超过它锁带来的优点，查询时会增加读一个索引层的磁盘次数。")])]),a._v(" "),v("h4",{attrs:{id:"垂直分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垂直分表"}},[a._v("#")]),a._v(" 垂直分表")]),a._v(" "),v("p",[a._v("把主键和一些列放在一个表，再把主键和另外一些列放在另一个表")]),a._v(" "),v("h5",{attrs:{id:"适用场景-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-4"}},[a._v("#")]),a._v(" 适用场景")]),a._v(" "),v("ul",[v("li",[a._v("把常用的列和不常用的列进行拆分")]),a._v(" "),v("li",[a._v("可以使数据行变小，一个数据页可以存储更多的数据，查询时减少I/O次数")])]),a._v(" "),v("h5",{attrs:{id:"缺点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("管理冗余列，查询时需要进行join操作")])]),a._v(" "),v("h4",{attrs:{id:"两者的缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两者的缺点"}},[a._v("#")]),a._v(" 两者的缺点")]),a._v(" "),v("ul",[v("li",[a._v("有些分表基于应用层的算法，一旦算法改变整个分表的逻辑改变，扩展性比较差")]),a._v(" "),v("li",[a._v("对于应用层来说，逻辑算法会增加开发成本")])]),a._v(" "),v("h2",{attrs:{id:"mysql的复制原理及负载均衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql的复制原理及负载均衡"}},[a._v("#")]),a._v(" MySQL的复制原理及负载均衡")]),a._v(" "),v("h3",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),v("p",[a._v("在主库上把数据的更改记录到二进制日志中，从库把主库的日志复制到自己的中继日志，从库读取中继日志中的事件，将其重放到从库数据中。")]),a._v(" "),v("h3",{attrs:{id:"解决的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决的问题"}},[a._v("#")]),a._v(" 解决的问题")]),a._v(" "),v("ul",[v("li",[a._v("数据的分布 ：随意的停止和开始复制，并在不同地理位置分布数据备份")]),a._v(" "),v("li",[a._v("负载均衡：降低单个服务器的压力")]),a._v(" "),v("li",[a._v("高可用和故障切换：帮助应用程序避免单点失败")]),a._v(" "),v("li",[a._v("升级测试：可以使用更高版本的MySQL作为从库进行测试")])])])}),[],!1,null,null,null);t.default=s.exports}}]);